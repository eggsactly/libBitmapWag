#  This file is part of libBitmapWag.
#
#  libBitmapWag is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  libBitmapWag is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public License
#  along with libBitmapWag.  If not, see <https://www.gnu.org/licenses/>.


# DOCUMENTATION: 
# This Makefile has `make', `make clean', `make debug' and `make install' 
# directives. 
#
# The result of running `make' is: 
# 1. An example program will be created in the same directory as this Makefile 
#    and will be named $(EXE)
# 2. All .o files generated in build process will be placed in a generated obj/ 
#    directory
# 3. All .h files will be placed in a generated include/ directory
# 4. A .a files will be placed in a generated lib/ directory
# 5. A .so files will be placed in a generated bin/ directory
# 
# The result of running `make install' will be that the contents of the 
# include/ lib/ and bin/ directories will be placed in their respective 
# directores /usr/local. The default /usr/local directory can be overridden by 
# defining the PREFIX enviroment variable. 
# make install will likely need to be run as sudo.
# 
# The result of running `make clean' will result in all files generated by this
# Makefile to be deleted. 
#
# `make debug' has the same action as a clean and make, where the make has the 
# -g flag applied to all compile operations to allow use with the gdb debugger. 
# for both the library and example program. 
#
# This Makefile is sufficiently generic to be reused in new C library projects 
# with the only change required being the variables `EXE' and `LIBNAME'.
#
# This Makefile is meant to compile one library, along with one example program
# No additional modifications to this Makefile are required if the following 
# conditions are met. 
# 1. Any source and header file that is meant to be part of the library shall 
#    start with the prefix `lib' in the filename. 
# 2. Any source and header file that is meant to be part of the example program
#    shall have no `lib' prefix the filename. 
# 3a. All source files to be compiled shall end with `.c', 
# 4b. All header files shall end with `.h'
# 4. All source and header files shall be placed in the same directory as this 
#    Makefile in the project. 

# Compiler 
CC?=gcc
# Installation location
PREFIX?=/usr/local

# name of example executable 
EXE:=bitmap
# name of the libary
LIBNAME:=libBitmapWag

# This make file will build every file it sees in the directory ending with a 
# .c extension 
SRC_EXTENSION:=c
# Build process creates the folders obj/, lib/, include/, and bin/ for the .o, 
# .a, .h, and .so files respectively. 
OBJ_DIR:=obj
LIB_DIR:=lib
INC_DIR:=include
BIN_DIR:=bin

# Character separating directory levels can be OS dependent (Linux vs Windows)
# Hard coded / for Linux and Unix systems 
DIR_CHAR:=/

# All source files starting with lib are to be part of the library 
LIBSRCS:=$(wildcard lib*.$(SRC_EXTENSION))
LIBOBJS:=$(patsubst %.$(SRC_EXTENSION), $(OBJ_DIR)$(DIR_CHAR)%.o, $(LIBSRCS))
LIBHEADS:=$(wildcard lib*.h)
LIBINCS:=$(LIBHEADS:lib%=%)
LIBINCS:=$(patsubst %, $(INC_DIR)$(DIR_CHAR)%, $(LIBINCS))

# Filter out the source files for the example application from the library files
SOURCES:=$(filter-out $(LIBSRCS), $(wildcard *.$(SRC_EXTENSION)))
OBJECTS:=$(patsubst %.$(SRC_EXTENSION), $(OBJ_DIR)$(DIR_CHAR)%.o, $(SOURCES))

# Set compile flags
CFLAGS:=-fPIC -O3
INCFLAGS:=$(patsubst %, -I%, $(INC_DIR)) -I.

DEBUG:=

# Build the test executable, static, and dynamic libraries 
.PHONY: all
all: $(LIB_DIR) $(LIBINCS) $(BIN_DIR) $(BIN_DIR)$(DIR_CHAR)$(LIBNAME).so 
all: $(LIB_DIR)$(DIR_CHAR)$(LIBNAME).a $(EXE)

# The debug option cleans and builds the application with the -g compile flag
.PHONY: debug
debug: clean 
debug: DEBUG+=-g 
debug: all

# Link together the example application using static linking, 
# put it in the root of the project. 
$(EXE): $(OBJECTS) $(LIB_DIR)$(DIR_CHAR)$(LIBNAME).a
	$(CC) $^ -o $@

# Create .a 
$(LIB_DIR)$(DIR_CHAR)$(LIBNAME).a: $(LIBOBJS)
	ar rcs $@ $^

# Create .so
$(BIN_DIR)$(DIR_CHAR)$(LIBNAME).so: $(LIBOBJS)
	$(CC) $^ -shared -o $@

# Compile individual sources to .o
$(OBJ_DIR)$(DIR_CHAR)%.o: %.$(SRC_EXTENSION) $(OBJ_DIR) $(LIBINCS)
	$(CC) $(DEBUG) -c $(INCFLAGS) $(CFLAGS) $< -o $@ -DAPP_NAME=\"$(EXE)\"

# This directive is called from all with the strings in the variable $(LIBINCS)
# Copy header files to special inc directory and lock the files so that no one
# accidentally edits the copied include files because if they're being used as 
# as a reference for the functions in the libraries, and they change out of 
# sync with the libraries, developers will have a bad time during the linking
# phase of building the program. 
$(INC_DIR)$(DIR_CHAR)%.h: lib%.h $(INC_DIR)
	cp -f $< $@
	chmod a-w $@

# Generate directories 
$(LIB_DIR):
	mkdir $(LIB_DIR)

$(OBJ_DIR):
	mkdir $(OBJ_DIR)
		
$(INC_DIR):
	mkdir $(INC_DIR)

$(BIN_DIR):
	mkdir $(BIN_DIR)

# Clean Directive, remove all generated files 
.PHONY: clean
clean:
ifeq ($(UNAME_S),Windows_NT) 
	DEL /F /s $(EXE) $(TESTDIR)$(DIR_CHAR)$(TEST_EXE)
	rd /q /s $(OBJ_DIR) $(LIB_DIR) $(INC_DIR) $(BIN_DIR)
else
	rm -rf $(EXE) $(OBJ_DIR) $(LIB_DIR) $(INC_DIR) $(BIN_DIR)
endif

# Install Directive, copy the library to the system 
.PHONY: install
install: all
	# Copy for applications to compile
	install $(INC_DIR)$(DIR_CHAR)*.h $(PREFIX)$(DIR_CHAR)$(INC_DIR)
	# Copy for applications to link dynamically
	install $(BIN_DIR)$(DIR_CHAR)*.so $(PREFIX)$(DIR_CHAR)$(BIN_DIR)
	# Copy for applications to link statically 
	install $(LIB_DIR)$(DIR_CHAR)*.a $(PREFIX)$(DIR_CHAR)$(LIB_DIR)

